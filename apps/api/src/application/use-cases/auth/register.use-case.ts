import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcryptjs';
import { User } from '../../../domain/entities/user.entity';
import { UserRepositoryImpl } from '../../../infrastructure/repositories/user.repository.impl';
import {
  LoginResponseDto,
  RegisterRequestDto,
  UserDto,
} from '../../dtos/auth.dto';

@Injectable()
export class RegisterUseCase {
  constructor(
    private readonly userRepository: UserRepositoryImpl,
    private readonly jwtService: JwtService,
  ) {}

  async execute(request: RegisterRequestDto): Promise<LoginResponseDto> {
    // Check if user already exists
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new Error('User already exists');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(request.password, 10);

    // Create user entity
    const user = new User(
      '', // ID will be generated by repository
      request.email,
      request.name,
      hashedPassword,
      false, // passwordUpdated
      undefined, // googleId
      undefined, // azureAdId
      request.phone,
      undefined, // avatar
      request.roles || ['student'], // default role
      request.origin,
      undefined, // dateOfBirth
      undefined, // organizationId
      new Date(), // createdAt
    );

    // Save user
    const savedUser = await this.userRepository.save(user);

    // Generate tokens
    const accessToken = this.jwtService.sign({
      sub: savedUser.id,
      email: savedUser.email,
      roles: savedUser.roles,
    });

    const refreshToken = this.jwtService.sign(
      { sub: savedUser.id, type: 'refresh' },
      { expiresIn: '7d' },
    );

    const userDto = this.mapToUserDto(savedUser);

    return new LoginResponseDto(accessToken, refreshToken, userDto, false);
  }

  private mapToUserDto(user: User): UserDto {
    return new UserDto(
      user.id,
      user.email,
      user.roles,
      user.name,
      user.phone,
      user.avatar,
      user.origin,
      user.organization,
    );
  }
}
